# 백준 11053.S2.가장 긴 증가하는 부분 수열_파이썬 풀이
# 체감 난이도: 음.. 일단 문제가 너무 불친절하다. 부분 수열의 개수가 정확히 어떻게 나온건지를 이해하기가 어렵다.
# 문제 설명을 이렇게 할거면 예제 입력을 하나 정도는 더 추가해줬어야 한다고 생각.
# 풀이 난이도 자체도 조금 있는 편이지만 문제를 정확히 이해하는 데까지 시간이 걸려서
# 문제를 이렇게도 이해해봤다가 저렇게도 이해해봤다가 해서 코드를 여러번 짜느라 시간을 많이 낭비하게 하는 문제.
# 그렇지만 문제를 제대로 이해하고 풀면 풀이 자체가 dp 입문으로 이해를 돕는데 활용하기 좋은 문제인거 같다.
"""
# 핵심 내용
- dp 문제 유형이 어떤 식으로 나오는지 알아보고 다양한 활용 문제를 많이 풀어보는게 중요함.
"""

import sys

N = int(sys.stdin.readline())

arr = list(map(int, sys.stdin.readline().split()))

dp = [1]*N

for i in range(1, N):
    for j in range(i):
        if arr[i] > arr[j]:
            dp[i] = max(dp[i], dp[j]+1)  
            # arr[i]가 추가될 수 있는 수열 중
            # 이미 계산된 dp[j] 즉 arr[j]로 만들 수 있는 수열이 더 길면 거기에 arr[i]를 추가한 길이를
            # dp[i]에 저장 그러므로 dp[j]+1
            # 반대로 이미 계산된 dp[i] 즉 arr[i]로 만들 수 있는 수열이 더 길면 
            # arr[j]값을 추가하지 않은 이미 계산된 기존 수열의 길이 재저장
sys.stdout.write(f"{max(dp)}")