# 백준 S2.나무 자르기_파이썬 풀이
# 체감 난이도: S2 정도 수준처럼 느껴졌다. 아님 조금 더 쉬운..?
# 알고리즘 없이 풀 수 있는 문제
"""
# 핵심내용
- 요소들간의 차를 구할 때 현재 구한 차이 값에 앞에 있는 요소 개수 만큼 곱해주는 것이 포인트.
- 나무이기 때문에 현재 구한 차이 값만큼 이전 요소 즉 앞의 나무들에서도 모두 잘려나가기 때문
"""

import sys
import math

N, M = map(int, sys.stdin.readline().split())

trees = sorted(list(map(int, sys.stdin.readline().split())), reverse=True)

cut = 0

for i in range(N - 1):

    cut += (trees[i] - trees[i + 1]) * (i + 1)  # 현재 나무와 다음 나무의 차 값을 구하고, 앞의 요소 개수 곱하기.

    if cut >= M:  # 잘린 나무 길이가 필요한 최소 값 이상 도달한 시점.
        sys.stdout.write(f"{trees[i + 1] + math.floor((cut - M) / (i + 1))}")
        # trees[i+1] 값을 기준으로 자른 상태에서 이를 낭비 없이 최적으로 자르기 위해
        # 잘린 값과 필요한 값의 차를 구하고 한 그루당 얼마나 덜 잘려도 되는지 구해서 이를 trees[i+1]에 더함
        # 이 때 나눈 값을 내림 해주어야 모자라지 않게 자를 수 있다. (원래 있는 값에서 덜 자르기 위해 높이를 더하는 것이기 때문)
        exit(0)

sys.stdout.write(f"{trees[-1] - math.ceil((M - cut) / N)}")
# 최종 연산까지 온 경우는 마지막 나무길이의 높이로 설정해도 필요한 값을 못채운 경우이다.
# 최종 연산은 한 그루당 얼마나 더 잘라야 하는 지를 계산해서 마지막 나무 길이에서 빼준다.
# 이 때는 한 그루당 더 잘라야하는 값이 소수점으로 나온 경우 이를 내림한다.
# 남아있는 소수점 값보다 더 크게 잘라내야 모자라지 않게 자를 수 있기 때문.